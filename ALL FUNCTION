WHERE всегда идет до GROUP BY
HAVING всегда идет после GROUP BY
_________________________________________________________________________________________________________________________________________________
> SELECT DISTINCT ... FROM ...				-- выбирает только уникальные значения
> SELECT ... AS ... FROM ...				-- выбирает что-то с названием столбика как AS
> SELECT DISTINCT ... FROM ... LIMIT N, X               -- выбирает X элементов, начиная с N
> SELECT ... FROM ... ORDER BY 1 DESC, 2            	-- Если DESC то сортирует в порядке убывания. Сначала отсортирует 1 в обратном порядке,
							   затем 2 в обычном порядке (алфавитном, по возрастанию)

> SELECT ... FROM ... WHERE ... AND / OR / NOT          -- Приоритеты операций: круглые скобки --> умножение  (*),  деление (/) --> 
							   сложение  (+), вычитание (-) --> операторы сравнения (=, >, <, >=, <=, <>) --> 
							   NOT --> AND --> OR
> SELECT ... FROM ... WHERE ... IN / NOT IN (.., ..) /  -- IN предлагает один из вариантов, BETWEEN промежуток
				BETWEEN ... AND ...  
> SELECT ... FROM ... WHERE ... LIKE '%..%' /		-- % означает любое число символов (включая пустоту), _ означает конкретно 1 любой символ
				LIKE '___'


> SELECT A FROM ... WHERE EXISTS (SELECT A FROM ...)	-- Выбирает значения, если существует такое A...
_________________________________________________________________________________________________________________________________________________
ОБЪЕДИНЕНИЯ ЗАПРОСОВ
> SELECT ... FROM ... UNION (UNION ALL)			-- Позволяет присоединять строки из одного запроса к строкам из 
  SELECT ... FROM ... UNION ...				   другого запроса (все - UNION ALL, или удаляя дубликаты UNION)
> SELECT ... FROM ... INTERSECT (EXCEPT)		-- Позволяет оставить только те строки, которые пересекаются в запросах /
  SELECT ... FROM ...					   или из строк первого запроса исключаются строки второго (EXCEPT)
_________________________________________________________________________________________________________________________________________________
ВСЕВОЗМОЖНЫЕ ДЖОИНЫ
> INNER JOIN / LEFT JOIN / RIGHT JOIN ... ON ... = ...
> CASE WHEN ... THEN ...	
       WHEN ... THEN ...
       ELSE ...
  END AS Name
  //
  IF (условие, ... если TRUE, ... если FALSE)

_________________________________________________________________________________________________________________________________________________
ГРУППОВЫЕ ФУНКЦИИ
Группировать можно по одному значению, но можно и по нескольким значениям: ... GROUP BY name, age ... Тогда будут сгруппированы все уникальные
сочетания ФИО и возраста в данных.

> SELECT ..., avg(...), sum(...), count(...) FROM ... GROUP BY ...	 -- с данными можно проводить операции агрегирования (среднее, сумма,
									    число), но в случае, если есть GROUP BY.
> SELECT ..., count(DISTINCT title) FROM ... GROUP BY ...		 -- DISTINCT внутри функции агрегирования позволяет посчитать только
									    уникальные значения
> SELECT ..., avg(...), min(...), max(...) FROM ... GROUP BY ...
> SELECT ..., sum(... * ...) FROM ... GROUP BY ...			 -- может использоваться не одна переменная, а даже * / нескольких
> SELECT ..., round(avg(...), 2) FROM ... GROUP BY ...			 -- и так можно
> SELECT ..., cast(avg(...) AS decimal (10, 2)) FROM ... GROUP BY ...	 -- cast позволяет преобразовать данные (даже выражение) в другой формат,
									    в т.ч. с округление до 2 знаков после запятой и длиной в 10 знаков.
> SELECT A FROM Table GROUP BY A HAVING count(B) > 2			 -- позволяет с помощью группировки и having выбирать рассчитываемое
							   		    условие (MIX, MAX, AVG, Count ...)
_________________________________________________________________________________________________________________________________________________
ВЛОЖЕННЫЕ ЗАПРОСЫ
> SELECT ... FROM ... WHERE ... = (SELECT MIN() FROM ...)		 -- фактически вложенный запрос позволяет:
									    а) сравнить выражения с результатом вложенного запроса
									    б) определить, включено ли выражение в результаты вложенного запроса
									    в) проверить, выбирает ли запрос определенные строки
Вложенный запрос, возвращающий одно значение, может использоваться в выражениях как обычный операнд, например, его можно + - / ...
> SELECT ... FROM ... WHERE ABS(amount - (SELECT AVG(amount) FROM ...)) > 3
> SELECT ... FROM ... WHERE ... IN (SELECT ... FROM ... GROUP BY ... HAVING ... > 3)
> ... WHERE ... = < > != ANY (SELECT ... )               		 -- По очереди подставляет и что-то должно соотноситься либо с одним из (ANY)
                         ALL (SELECT ... )                  		    или всеми (ALL)
Операторы ANY и ALL используются в SQL для сравнения некоторого значения с результирующим набором вложенного запроса, состоящим из одного столбца. 
Тип данных столбца, возвращаемого вложенным запросом, должен совпадать с типом данных столбца (или выражения), с которым происходит сравнение.
Операторы ALL и ANY можно использовать только с вложенными запросами.

_________________________________________________________________________________________________________________________________________________
> ... CONVERT(datetime, [date], 3) 			-- Переводит запись [date] (или другую) в формат datetime (или любой другой), где 3 - 
							   тип формата, у даты и времени самый большой спектр форматов.

> ISNULL / COALESCE 					-- Еще предстоит изучить
> WITH ABC (... , ... , ...) AS (SELECT ... FROM ... UNION ...) 	 -- создает оконную функцию (CREATE VIEW), дальше его можно использовать
									    в обычном SELECT (SELECT ... FROM ABC...)

> 

_________________________________________________________________________________________________________________________________________________
МАТЕМАТИЧЕСКИЕ ФУНКЦИИ:
CEILING(x) 		-- возвращает наименьшее целое число, большее или равное x (округляет до целого числа в большую сторону)
ROUND(x, k)		-- округляет значение x до k знаков после запятой, если k не указано – x округляется до целого
FLOOR(x)		-- возвращает наибольшее целое число, меньшее или равное x (округляет до  целого числа в меньшую сторону)
POWER(x, y)		-- возведение x в степень y
SQRT(x)			-- квадратный корень из x
DEGREES(x)		-- конвертирует значение x из радиан в градусы
RADIANS(x)		-- конвертирует значение x из градусов в радианы
ABS(x)			-- модуль числа x
PI()			-- pi = 3.1415926...
=			-- равно
<>			-- не равно
_________________________________________________________________________________________________________________________________________________
ДАТА И ВРЕМЯ:
DATEDIFF(datepart, startdate, enddate)    -- возвращает разницу во времени, обозначенном аргументом datepart, за период, указанный в аргументах 
					     startdate и enddate; возвращает значение integer
					     datepart может быть year (yy), quarter (qq), month (mm), day (dd) ...
MONTH(date)				  -- возвращает название месяца в формате integer
YEAR(date)				  -- возвращает год в формате integer
MONTHNAME(date)				  -- возвращает название месяца в формате текста на англ. языке (функция не факт, что работает везде)
					     чаще можно встретить DATENAME()
DATENAME(datepart, date)		  -- формат даты datepart и выдает название, например, месяца, дня недели

_________________________________________________________________________________________________________________________________________________
ЗАПРОСЫ КОРРЕКТИРОВКИ ДАННЫХ
> CREATE TABLE ...(... INT PRIMARY KEY AUTO_INCREMENT, ... VARCHAR(50), ... DATE, ... DECIMAL(8, 2), ... INT);
> CREATE TABLE ... AS SELECT ... FROM ... WHERE ...						-- можно создать таблицу из таблицу через AS
> INSERT INTO ... VALUES (..., ..., ...)							-- можно вставалять через , несколько строк
> INSERT INTO book(title, author, amount) VALUES (..., ..., ...), (..., ..., ...), (), () ...   -- можно выбирать столбцы, куда вставляются значения
> INSERT INTO book(title, author, amount) SELECT title, author, amount FROM supply		-- можно вставлять в таблицу селект из другой таблицы
> INSERT INTO ...() SELECT ..., ..., ... FROM ... WHERE ...

> UPDATE ...(таблица) SET значение WHERE условие для тех строк, которые изменяются 
> UPDATE "my_table" SET "a" = 5; 			-- такая запись позволяет в именах таблиц или столбцов таблиц использовать 
							   в т.ч. select и пр. функции
> UPDATE book SET buy = IF(amount>buy, buy, amount), price = IF(buy=0,price*0.9,price);		-- обновление + IF с подстановкой
> UPDATE book, supply 										-- обновление с данными из двух таблиц
  SET book.amount=IF(book.title=supply.title, book.amount+supply.amount, book.amount),		   их надо связывать через WHERE
      book.price=IF(book.title=supply.title, (book.price+supply.price)/2, book.price)
  WHERE book.title=supply.title AND book.author=supply.author;

> DELETE FROM ...										-- удаляет все строки из таблицы
> DELETE FROM supply 										-- удаляет книги всех авторов, у которых в другой
  WHERE author IN (SELECT author FROM book  GROUP BY author HAVING sum(amount)>10);		   таблице в сумме больше 10 книг

> CREATE TABLE ... (... формат, ... формат, ... формат)
> CREATE TABLE ordering AS 									-- создать таблицу, взяв отдельные значения из
  SELECT author, title, (SELECT floor(avg(amount)) FROM book) AS amount				   другой таблицы с определенными условиями
  FROM book WHERE amount < (SELECT avg(amount) FROM book)







