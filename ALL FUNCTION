Концептуальная модель - это схема со связями без каких-либо полей. Просто прямоугольнички и связи между ними.
Логическая модель - это концептуальная модель, но со связями между отдельными полями (один ко многим, или многие ко многим).


WHERE всегда идет до GROUP BY
HAVING всегда идет после GROUP BY
_________________________________________________________________________________________________________________________________________________
> SELECT DISTINCT ... FROM ...				-- выбирает только уникальные значения
> SELECT ... AS ... FROM ...				-- выбирает что-то с названием столбика как AS
> SELECT DISTINCT ... FROM ... LIMIT N, X               -- выбирает X элементов, начиная с N
> SELECT ... FROM ... ORDER BY 1 DESC, 2            	-- Если DESC то сортирует в порядке убывания. Сначала отсортирует 1 в обратном порядке,
							   затем 2 в обычном порядке (алфавитном, по возрастанию)

> SELECT ... FROM ... WHERE ... AND / OR / NOT          -- Приоритеты операций: круглые скобки --> умножение  (*),  деление (/) --> 
							   сложение  (+), вычитание (-) --> операторы сравнения (=, >, <, >=, <=, <>) --> 
							   NOT --> AND --> OR
> SELECT ... FROM ... WHERE ... IN / NOT IN (.., ..) /  -- IN предлагает один из вариантов, BETWEEN промежуток
				BETWEEN ... AND ...  
> SELECT ... FROM ... WHERE ... LIKE '%..%' /		-- % означает любое число символов (включая пустоту), _ означает конкретно 1 любой символ
				LIKE '___'


> SELECT A FROM ... WHERE EXISTS (SELECT A FROM ...)	-- Выбирает значения, если существует такое A...
_________________________________________________________________________________________________________________________________________________
ОБЪЕДИНЕНИЯ ЗАПРОСОВ
> SELECT ... FROM ... UNION (UNION ALL)			-- Позволяет присоединять строки из одного запроса к строкам из 
  SELECT ... FROM ... UNION ...				   другого запроса (все - UNION ALL, или удаляя дубликаты UNION)
> SELECT ... FROM ... INTERSECT (EXCEPT)		-- Позволяет оставить только те строки, которые пересекаются в запросах /
  SELECT ... FROM ...					   или из строк первого запроса исключаются строки второго (EXCEPT)
_________________________________________________________________________________________________________________________________________________
ВСЕВОЗМОЖНЫЕ ДЖОИНЫ 		(https://habr.com/ru/post/448072/)		(https://habr.com/ru/post/450528/)
Связь «один ко многим» (-->) имеет место, когда одной записи главной таблицы соответствует несколько записей связанной таблицы, а каждой записи 
связанной таблицы соответствует только одна запись главной таблицы. Первичные ключи (PK) в таком случае должны быть в обоих таблицах.
	Например: 1 автор, много книг
Связь «многие ко многим» (<-->) имеет место когда каждой записи одной таблицы соответствует несколько записей во второй, и наоборот, каждой записи 
второй таблицы соответствует несколько записей в первой. Для реализации этой связи используют дополнительную таблицу, в которой содержатся FK
(Foreign Key), связанные с PK в обеих таблицах.
	Например: один автор может написать несколько книг, а одна книга может быть написана несколькими авторами 

> INNER JOIN ... ON ...		-- каждая строка одной таблицы сопоставляется с каждой строкой второй таблицы; для полученной «соединённой» 
				   строки проверяется условие соединения; если условие истинно, в таблицу результата добавляется 
				   соответствующая «соединённая» строка;
> 1 LEFT JOIN 2 ON ...   	-- включается внутреннее соединение (INNER JOIN) первой и второй таблицы в соответствии с условием; затем в 
  / RIGHT			   результат добавляются те записи первой таблицы, которые не вошли во внутреннее соединение на шаге 1, для 
				   таких записей соответствующие поля второй таблицы заполняются значениями NULL.
Возможно использовать USING(), если при джоине поля в соединяемых таблицах имеют одинаковое название.
Пример: SELECT title, name_author, author.author_id FROM author INNER JOIN book ON author.author_id = book.author_id;
	SELECT title, name_author, author_id FROM author INNER JOIN book USING(author_id);
	То есть таблицы соединяются по author_id, присутствующему в таблицах author и book. Поэтому в SELECT не нужно точно указывать поле
	автора, а вместо ON применить USING.

> CASE WHEN ... THEN ...	
       WHEN ... THEN ...
       ELSE ...
  END AS Name
  //
  IF (условие, ... если TRUE, ... если FALSE)

_________________________________________________________________________________________________________________________________________________
ГРУППОВЫЕ ФУНКЦИИ
Группировать можно по одному значению, но можно и по нескольким значениям: ... GROUP BY name, age ... Тогда будут сгруппированы все уникальные
сочетания ФИО и возраста в данных.

> SELECT ..., avg(...), sum(...), count(...) FROM ... GROUP BY ...	 -- с данными можно проводить операции агрегирования (среднее, сумма,
									    число), но в случае, если есть GROUP BY.
> SELECT ..., count(DISTINCT title) FROM ... GROUP BY ...		 -- DISTINCT внутри функции агрегирования позволяет посчитать только
									    уникальные значения
> SELECT ..., avg(...), min(...), max(...) FROM ... GROUP BY ...
> SELECT ..., sum(... * ...) FROM ... GROUP BY ...			 -- может использоваться не одна переменная, а даже * / нескольких
> SELECT ..., round(avg(...), 2) FROM ... GROUP BY ...			 -- и так можно
> SELECT ..., cast(avg(...) AS decimal (10, 2)) FROM ... GROUP BY ...	 -- cast позволяет преобразовать данные (даже выражение) в другой формат,
									    в т.ч. с округление до 2 знаков после запятой и длиной в 10 знаков.
> SELECT A FROM Table GROUP BY A HAVING count(B) > 2			 -- позволяет с помощью группировки и having выбирать рассчитываемое
							   		    условие (MIX, MAX, AVG, Count ...)
_________________________________________________________________________________________________________________________________________________
ВЛОЖЕННЫЕ ЗАПРОСЫ
> SELECT ... FROM ... WHERE ... = (SELECT MIN() FROM ...)		 -- фактически вложенный запрос позволяет:
									    а) сравнить выражения с результатом вложенного запроса
									    б) определить, включено ли выражение в результаты вложенного запроса
									    в) проверить, выбирает ли запрос определенные строки
Вложенный запрос, возвращающий одно значение, может использоваться в выражениях как обычный операнд, например, его можно + - / ...
> SELECT ... FROM ... WHERE ABS(amount - (SELECT AVG(amount) FROM ...)) > 3
> SELECT ... FROM ... WHERE ... IN (SELECT ... FROM ... GROUP BY ... HAVING ... > 3)
> ... WHERE ... = < > != ANY (SELECT ... )               		 -- По очереди подставляет и что-то должно соотноситься либо с одним из (ANY)
                         ALL (SELECT ... )                  		    или всеми (ALL)
Операторы ANY и ALL используются в SQL для сравнения некоторого значения с результирующим набором вложенного запроса, состоящим из одного столбца. 
Тип данных столбца, возвращаемого вложенным запросом, должен совпадать с типом данных столбца (или выражения), с которым происходит сравнение.
Операторы ALL и ANY можно использовать только с вложенными запросами.

_________________________________________________________________________________________________________________________________________________
НОВЫЕ И СЛОЖНЫЕ
> ... CONVERT(datetime, [date], 3) 			-- Переводит запись [date] (или другую) в формат datetime (или любой другой), где 3 - 
							   тип формата, у даты и времени самый большой спектр форматов.

> ISNULL / COALESCE 					-- Еще предстоит изучить
Пример:
	SELECT name_author, IF(sum(amount) IS NULL, 0, sum(amount)) FROM author a LEFT JOIN book b ON a.author_id=b.author_id GROUP BY name_author
	SELECT name_author, COALESCE(sum(amount), 0) FROM author a LEFT JOIN book b ON a.author_id=b.author_id GROUP BY name_author

> WITH ABC (... , ... , ...) AS (SELECT ... FROM ... UNION ...) 	 -- создает оконную функцию (CREATE VIEW), дальше его можно использовать
									    в обычном SELECT (SELECT ... FROM ABC...)

> ROW_NUMBER ( ) OVER ( [PARTITION BY value_expression , ... [ n ]] ORDER BY ...)
  Короче. row_number добавляет нумерацию строкам по какому-то условию (OVER). Можно написать row_number() over(order by ...), тогда пронумеруются
  в порядке убывания. Если добавить PARTION BY, то он будет нумеровать уже последовательность внутри некоторого кластера, заданного этим параметром.
  Пример: SELECT Название, Автор, Жанр, Выручка FROM 
	  (SELECT b.title AS Название, name_author AS Автор, name_genre AS Жанр, price*amount AS Выручка, ROW_NUMBER() OVER (PARTITION BY name_genre 
	  ORDER BY price*amount DESC) AS rang 
	  FROM book b INNER JOIN author a USING(author_id) INNER JOIN genre g USING(genre_id)) AS t
	  WHERE rang<=2
_________________________________________________________________________________________________________________________________________________
МАТЕМАТИЧЕСКИЕ ФУНКЦИИ:
CEILING(x) 		-- возвращает наименьшее целое число, большее или равное x (округляет до целого числа в большую сторону)
ROUND(x, k)		-- округляет значение x до k знаков после запятой, если k не указано – x округляется до целого
FLOOR(x)		-- возвращает наибольшее целое число, меньшее или равное x (округляет до  целого числа в меньшую сторону)
POWER(x, y)		-- возведение x в степень y
SQRT(x)			-- квадратный корень из x
DEGREES(x)		-- конвертирует значение x из радиан в градусы
RADIANS(x)		-- конвертирует значение x из градусов в радианы
ABS(x)			-- модуль числа x
PI()			-- pi = 3.1415926...
=			-- равно
<>			-- не равно


RAND() 			-- возвращает случайное число от 0 до 1 (не включая 1), если * 365, то от 0 до 365 (не включая 365)

_________________________________________________________________________________________________________________________________________________
ДАТА И ВРЕМЯ:
DATEDIFF(datepart, startdate, enddate)    -- возвращает разницу во времени, обозначенном аргументом datepart, за период, указанный в аргументах 
					     startdate и enddate; возвращает значение integer
					     datepart может быть year (yy), quarter (qq), month (mm), day (dd) ...
DATE_ADD(дата, INTERVAL число datepart)   -- к дате прибавляет указанное число, выраженное в днях, месяцах и пр. и возвращает новую дату. 
	где datepart (использовать прописные буквы) – это день (DAY), месяц(MONTH), неделя(WEEK) и пр., 
  	    число – целое число,
 	    дата – значение даты или даты и времени.
Пример: DATE_ADD('2020-02-02', INTERVAL 45 DAY) возвращает 18 марта 2020 года

MONTH(date)				  -- возвращает название месяца в формате integer
YEAR(date)				  -- возвращает год в формате integer
MONTHNAME(date)				  -- возвращает название месяца в формате текста на англ. языке (функция не факт, что работает везде)
					     чаще можно встретить DATENAME()
DATENAME(datepart, date)		  -- формат даты datepart и выдает название, например, месяца, дня недели

_________________________________________________________________________________________________________________________________________________
ЗАПРОСЫ КОРРЕКТИРОВКИ ДАННЫХ
> CREATE TABLE ...(... INT PRIMARY KEY AUTO_INCREMENT, ... VARCHAR(50), ... DATE, ... DECIMAL(8, 2), ... INT);
> CREATE TABLE ... AS SELECT ... FROM ... WHERE ...				    -- можно создать таблицу из таблицу через AS
******
PRIMARY KEY AUTO_INCREMENT
NOT NULL обычно все ключи
FOREIGN KEY (связанное_поле_зависимой_таблицы) REFERENCES главная_таблица (связанное_поле_главной_таблицы)
ON DELETE ...   можно установить действия, которые выполняются для записей подчиненной таблицы при удалении связанной строки из главной таблицы
ON DELETE CASCADE  	-- автоматически удаляет строки из зависимой таблицы при удалении  связанных строк в главной таблице
ON DELETE SET NULL 	-- при удалении  связанной строки из главной таблицы устанавливает для столбца внешнего ключа значение NULL
ON DELETE SET DEFAULT   -- как SET NULL, но значение внешнего ключа устанавливается не в NULL, а в значение по умолчанию для данного столбца
ON DELETE RESTRICT	-- отклоняет удаление строк в главной таблице при наличии связанных строк в зависимой таблице.
Пример:
    CREATE TABLE book (book_id INT PRIMARY KEY AUTO_INCREMENT, 
    		       title VARCHAR(50), author_id INT NOT NULL, 
    		       genre_id INT, price DECIMAL(8,2), amount INT,
    	 	       FOREIGN KEY (author_id)  REFERENCES author (author_id),
		       FOREIGN KEY (genre_id)  REFERENCES genre (genre_id)) ON DELETE CASCADE;
******
> INSERT INTO ... VALUES (..., ..., ...)							-- можно вставалять через , несколько строк
> INSERT INTO book(title, author, amount) VALUES (..., ..., ...), (..., ..., ...), (), () ...   -- можно выбирать столбцы, куда вставляются значения
> INSERT INTO book(title, author, amount) SELECT title, author, amount FROM supply		-- можно вставлять в таблицу селект из другой таблицы
> INSERT INTO ...() SELECT ..., ..., ... FROM ... WHERE ...

> UPDATE ...(таблица) SET значение WHERE условие для тех строк, которые изменяются 
> UPDATE "my_table" SET "a" = 5; 			-- такая запись позволяет в именах таблиц или столбцов таблиц использовать 
							   в т.ч. select и пр. функции
> UPDATE book SET buy = IF(amount>buy, buy, amount), price = IF(buy=0,price*0.9,price);		-- обновление + IF с подстановкой
> UPDATE book, supply 										-- обновление с данными из двух таблиц
  SET book.amount=IF(book.title=supply.title, book.amount+supply.amount, book.amount),		   их надо связывать через WHERE
      book.price=IF(book.title=supply.title, (book.price+supply.price)/2, book.price)
  WHERE book.title=supply.title AND book.author=supply.author;

> DELETE FROM ...										-- удаляет все строки из таблицы
> DELETE FROM supply 										-- удаляет книги всех авторов, у которых в другой
  WHERE author IN (SELECT author FROM book  GROUP BY author HAVING sum(amount)>10);		   таблице в сумме больше 10 книг
  DELETE FROM A USING A INNER JOIN B ON ...							-- удаляет данные из связанных книг, нужно USING

> CREATE TABLE ... (... формат, ... формат, ... формат)
> CREATE TABLE ordering AS 									-- создать таблицу, взяв отдельные значения из
  SELECT author, title, (SELECT floor(avg(amount)) FROM book) AS amount				   другой таблицы с определенными условиями
  FROM book WHERE amount < (SELECT avg(amount) FROM book)

_________________________________________________________________________________________________________________________________________________





